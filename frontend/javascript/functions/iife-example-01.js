// 下面代码的运行结果是什么？

var b = 10;
(function b() {
    b = 20;
    console.log(b);
})();

/*
  这段代码的输出结果是 `function b()`。
  这是因为 JavaScript 中的函数表达式和函数声明处理方式的不同，以及函数表达式的函数名的特殊作用域规则。

  一、解释

  1. 变量声明与赋值
  首先，`var b = 10;` 声明了一个全局变量 `b` 并赋值为 `10`。

  2. 自调用函数表达式 (IIFE)
  接下来是一个自调用的函数表达式 `(function b() { ... })()`。

  3. 函数表达式的函数名
  函数表达式 `function b() { ... }` 的函数名 `b` 只在函数内部有效。这个 `b` 是一个只读的标识符，意味着在函数内部试图修改 `b` 实际上是无效的。
  在函数内部，`b` 的值是对当前函数自身的引用。需要注意的是，这个 `b` 和全局变量 `b` 不是同一个。

  4. 试图修改函数内的 `b`
  在函数内部，`b = 20;` 试图修改函数内的 `b`。但由于 `b` 是一个只读标识符，这个赋值操作不会生效。不过，JavaScript 引擎不会抛出错误，它只是静默地忽略这个赋值操作。

  5. 打印 `b`
  接下来执行 `console.log(b);`，此时 `b` 引用了当前函数自身，因此输出的是函数的定义。

  二、代码执行流程

  - `var b = 10;` 创建了一个全局变量 `b`，值为 `10`。
  - `(function b() { ... })` 定义了一个函数表达式，函数名是 `b`，但这个 `b` 是局部的，只在函数内部可见。
  - 函数立即被调用。
  - 在函数内部，尝试将 `b` 赋值为 `20`，但由于 `b` 是只读的，这个赋值操作被忽略。
  - 打印 `b`，结果是函数自身。
*/
